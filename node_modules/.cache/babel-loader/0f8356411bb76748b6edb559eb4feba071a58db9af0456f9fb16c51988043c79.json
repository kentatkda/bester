{"ast":null,"code":"import { frame } from '../../frameloop/frame.mjs';\nconst toResolve = new Set();\nlet isScheduled = false;\nlet anyNeedsMeasurement = false;\nfunction measureAllKeyframes() {\n  if (anyNeedsMeasurement) {\n    // Write\n    toResolve.forEach(resolver => {\n      resolver.needsMeasurement && resolver.unsetTransforms();\n    });\n    // Read\n    toResolve.forEach(resolver => {\n      resolver.needsMeasurement && resolver.measureInitialState();\n    });\n    // Write\n    toResolve.forEach(resolver => {\n      resolver.needsMeasurement && resolver.renderEndStyles();\n    });\n    // Read\n    toResolve.forEach(resolver => {\n      resolver.needsMeasurement && resolver.measureEndState();\n    });\n  }\n  anyNeedsMeasurement = false;\n  isScheduled = false;\n  toResolve.forEach(resolver => resolver.complete());\n  toResolve.clear();\n}\nfunction readAllKeyframes() {\n  toResolve.forEach(resolver => {\n    resolver.readKeyframes();\n    if (resolver.needsMeasurement) {\n      anyNeedsMeasurement = true;\n    }\n  });\n}\nfunction flushKeyframeResolvers() {\n  readAllKeyframes();\n  measureAllKeyframes();\n}\nclass KeyframeResolver {\n  constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {\n    /**\r\n     * Track whether this resolver has completed. Once complete, it never\r\n     * needs to attempt keyframe resolution again.\r\n     */\n    this.isComplete = false;\n    /**\r\n     * Track whether this resolver is async. If it is, it'll be added to the\r\n     * resolver queue and flushed in the next frame. Resolvers that aren't going\r\n     * to trigger read/write thrashing don't need to be async.\r\n     */\n    this.isAsync = false;\n    /**\r\n     * Track whether this resolver needs to perform a measurement\r\n     * to resolve its keyframes.\r\n     */\n    this.needsMeasurement = false;\n    /**\r\n     * Track whether this resolver is currently scheduled to resolve\r\n     * to allow it to be cancelled and resumed externally.\r\n     */\n    this.isScheduled = false;\n    this.unresolvedKeyframes = [...unresolvedKeyframes];\n    this.onComplete = onComplete;\n    this.name = name;\n    this.motionValue = motionValue;\n    this.element = element;\n    this.isAsync = isAsync;\n  }\n  scheduleResolve() {\n    this.isScheduled = true;\n    if (this.isAsync) {\n      toResolve.add(this);\n      if (!isScheduled) {\n        isScheduled = true;\n        frame.read(readAllKeyframes);\n        frame.resolveKeyframes(measureAllKeyframes);\n      }\n    } else {\n      this.readKeyframes();\n      this.complete();\n    }\n  }\n  readKeyframes() {\n    const {\n      unresolvedKeyframes,\n      name,\n      element,\n      motionValue\n    } = this;\n    /**\r\n     * If a keyframe is null, we hydrate it either by reading it from\r\n     * the instance, or propagating from previous keyframes.\r\n     */\n    for (let i = 0; i < unresolvedKeyframes.length; i++) {\n      if (unresolvedKeyframes[i] === null) {\n        /**\r\n         * If the first keyframe is null, we need to find its value by sampling the element\r\n         */\n        if (i === 0) {\n          const currentValue = motionValue === null || motionValue === void 0 ? void 0 : motionValue.get();\n          const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n          if (currentValue !== undefined) {\n            unresolvedKeyframes[0] = currentValue;\n          } else if (element && name) {\n            const valueAsRead = element.readValue(name, finalKeyframe);\n            if (valueAsRead !== undefined && valueAsRead !== null) {\n              unresolvedKeyframes[0] = valueAsRead;\n            }\n          }\n          if (unresolvedKeyframes[0] === undefined) {\n            unresolvedKeyframes[0] = finalKeyframe;\n          }\n          if (motionValue && currentValue === undefined) {\n            motionValue.set(unresolvedKeyframes[0]);\n          }\n        } else {\n          unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];\n        }\n      }\n    }\n  }\n  unsetTransforms() {}\n  measureInitialState() {}\n  renderEndStyles() {}\n  measureEndState() {}\n  complete() {\n    this.isComplete = true;\n    this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);\n    toResolve.delete(this);\n  }\n  cancel() {\n    if (!this.isComplete) {\n      this.isScheduled = false;\n      toResolve.delete(this);\n    }\n  }\n  resume() {\n    if (!this.isComplete) this.scheduleResolve();\n  }\n}\nexport { KeyframeResolver, flushKeyframeResolvers };","map":{"version":3,"names":["frame","toResolve","Set","isScheduled","anyNeedsMeasurement","measureAllKeyframes","forEach","resolver","needsMeasurement","unsetTransforms","measureInitialState","renderEndStyles","measureEndState","complete","clear","readAllKeyframes","readKeyframes","flushKeyframeResolvers","KeyframeResolver","constructor","unresolvedKeyframes","onComplete","name","motionValue","element","isAsync","isComplete","scheduleResolve","add","read","resolveKeyframes","i","length","currentValue","get","finalKeyframe","undefined","valueAsRead","readValue","set","delete","cancel","resume"],"sources":["C:/Users/MEIP-users/Desktop/codes/react-ts/node_modules/framer-motion/dist/es/render/utils/KeyframesResolver.mjs"],"sourcesContent":["import { frame } from '../../frameloop/frame.mjs';\r\n\r\nconst toResolve = new Set();\r\nlet isScheduled = false;\r\nlet anyNeedsMeasurement = false;\r\nfunction measureAllKeyframes() {\r\n    if (anyNeedsMeasurement) {\r\n        // Write\r\n        toResolve.forEach((resolver) => {\r\n            resolver.needsMeasurement && resolver.unsetTransforms();\r\n        });\r\n        // Read\r\n        toResolve.forEach((resolver) => {\r\n            resolver.needsMeasurement && resolver.measureInitialState();\r\n        });\r\n        // Write\r\n        toResolve.forEach((resolver) => {\r\n            resolver.needsMeasurement && resolver.renderEndStyles();\r\n        });\r\n        // Read\r\n        toResolve.forEach((resolver) => {\r\n            resolver.needsMeasurement && resolver.measureEndState();\r\n        });\r\n    }\r\n    anyNeedsMeasurement = false;\r\n    isScheduled = false;\r\n    toResolve.forEach((resolver) => resolver.complete());\r\n    toResolve.clear();\r\n}\r\nfunction readAllKeyframes() {\r\n    toResolve.forEach((resolver) => {\r\n        resolver.readKeyframes();\r\n        if (resolver.needsMeasurement) {\r\n            anyNeedsMeasurement = true;\r\n        }\r\n    });\r\n}\r\nfunction flushKeyframeResolvers() {\r\n    readAllKeyframes();\r\n    measureAllKeyframes();\r\n}\r\nclass KeyframeResolver {\r\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {\r\n        /**\r\n         * Track whether this resolver has completed. Once complete, it never\r\n         * needs to attempt keyframe resolution again.\r\n         */\r\n        this.isComplete = false;\r\n        /**\r\n         * Track whether this resolver is async. If it is, it'll be added to the\r\n         * resolver queue and flushed in the next frame. Resolvers that aren't going\r\n         * to trigger read/write thrashing don't need to be async.\r\n         */\r\n        this.isAsync = false;\r\n        /**\r\n         * Track whether this resolver needs to perform a measurement\r\n         * to resolve its keyframes.\r\n         */\r\n        this.needsMeasurement = false;\r\n        /**\r\n         * Track whether this resolver is currently scheduled to resolve\r\n         * to allow it to be cancelled and resumed externally.\r\n         */\r\n        this.isScheduled = false;\r\n        this.unresolvedKeyframes = [...unresolvedKeyframes];\r\n        this.onComplete = onComplete;\r\n        this.name = name;\r\n        this.motionValue = motionValue;\r\n        this.element = element;\r\n        this.isAsync = isAsync;\r\n    }\r\n    scheduleResolve() {\r\n        this.isScheduled = true;\r\n        if (this.isAsync) {\r\n            toResolve.add(this);\r\n            if (!isScheduled) {\r\n                isScheduled = true;\r\n                frame.read(readAllKeyframes);\r\n                frame.resolveKeyframes(measureAllKeyframes);\r\n            }\r\n        }\r\n        else {\r\n            this.readKeyframes();\r\n            this.complete();\r\n        }\r\n    }\r\n    readKeyframes() {\r\n        const { unresolvedKeyframes, name, element, motionValue } = this;\r\n        /**\r\n         * If a keyframe is null, we hydrate it either by reading it from\r\n         * the instance, or propagating from previous keyframes.\r\n         */\r\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\r\n            if (unresolvedKeyframes[i] === null) {\r\n                /**\r\n                 * If the first keyframe is null, we need to find its value by sampling the element\r\n                 */\r\n                if (i === 0) {\r\n                    const currentValue = motionValue === null || motionValue === void 0 ? void 0 : motionValue.get();\r\n                    const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\r\n                    if (currentValue !== undefined) {\r\n                        unresolvedKeyframes[0] = currentValue;\r\n                    }\r\n                    else if (element && name) {\r\n                        const valueAsRead = element.readValue(name, finalKeyframe);\r\n                        if (valueAsRead !== undefined && valueAsRead !== null) {\r\n                            unresolvedKeyframes[0] = valueAsRead;\r\n                        }\r\n                    }\r\n                    if (unresolvedKeyframes[0] === undefined) {\r\n                        unresolvedKeyframes[0] = finalKeyframe;\r\n                    }\r\n                    if (motionValue && currentValue === undefined) {\r\n                        motionValue.set(unresolvedKeyframes[0]);\r\n                    }\r\n                }\r\n                else {\r\n                    unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    unsetTransforms() { }\r\n    measureInitialState() { }\r\n    renderEndStyles() { }\r\n    measureEndState() { }\r\n    complete() {\r\n        this.isComplete = true;\r\n        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);\r\n        toResolve.delete(this);\r\n    }\r\n    cancel() {\r\n        if (!this.isComplete) {\r\n            this.isScheduled = false;\r\n            toResolve.delete(this);\r\n        }\r\n    }\r\n    resume() {\r\n        if (!this.isComplete)\r\n            this.scheduleResolve();\r\n    }\r\n}\r\n\r\nexport { KeyframeResolver, flushKeyframeResolvers };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}